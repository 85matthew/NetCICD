# NetCICD #	NetCICD is a network automation framework developed from the start as a structured pipeline. It takes an industrial approach for network deployments, given the bulk nature of network changes.The first implementation is made for Cisco devices and uses VIRL/CML for testing, as it allows for multiple concurrent tests to be run. In networking, Continuous Development (CD) is not yet common practice. This is partly caused by lack of familiarity with the CD paradigm and lack of working tooling. NetCICD attempts to fill this void.NetCICD is inspired by the awesome work of [Kirk Byers](https://pynet.twb-tech.com), [Jason Edelman](http://jedelman.com/home/ansible-for-networking/), [Packetgeek](https://www.packetgeek.net/2016/02/kicking-the-tires-with-the-new-ansible-network-modules/), [Pete Lumbis](https://github.com/plumbis/interop17-troubleshooting) and countless others on Stackoverflow and other resources.## License ##The Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.### Copyright ###(c) Mark Sibering## Installing ##For the installation, refer to [the blog taking you though it](https://mynetarch.wordpress.com/category/network-automation/netcicd/).## Environment ##In order to test NetCICD, the following test environment is used:- VIRL 1.5 on VMWare Workstation. The FLAT network is used to access the routers- Gitlab- Jenkins## Mechanics ##NetCICD uses Ansible playbooks with roles to deploy configurations to networking equipment. As soon as a change is made by Ansible on a device, an Ansible handler is triggered for that host, which entails that additional tasks are run for that host. These tasks are located in the **handlers** folder under the **role** directory. [Normal conditions for the execution of handlers in Ansible](http://docs.ansible.com/ansible/latest/playbooks_error_handling.html#handlers-and-failure) apply.Task files in the roles are split into small files imported int the `main.yml` file. This allows for easy maintenance.The handler task triggers a test scenario for that host. For Behave, the scenarios can be found under the **files** folder in the **role** directory. Each test scenario has its own subdirectory, with in it one or more feature files (what has to be tested) and a **steps** folder (with the actual tests) expressed in Python. The tests use Ansible ad-hoc commands to retrieve state from the device.Again: the Python test scripts are split into multiple files to allow for easy maintenance. There is one file per subject.The reachability information required for the ansible ad-hoc commands to run the tests is retrieved from the Ansible hosts file. The tests need to run without user interaction. This requires the server to login based on password-less certificates. If that is not possible, the tests wil fail (the Behave test framework will respond with "Assertion failed").The templates are located in the **templates** directory and are expressed in Jinja2 format.Tasks for a role are imported in `main.yml` in the **tasks** directory and import the tasks per subject from the tasks directory.Role specific variables are located in the **vars** directory under the role. ### Roles ###NetCICD uses the following roles:- box- topology- reachability (IGP)- forwarding (P)- platform (PE)- user-domain- user# Automated testing #The crux of NetCICD is in automated testing. Automated testing allows for a network architect to use the Behaviour Driven Design (BDD) paradigm, a way of working often used in networking: the architect wants to see certain behaviour of the platform and devises configuration to make that happen.## Test types ##Tests come generically in three stages: - Unit testing (small tests)- Integration testing (medium tests)- Acceptance testing (large tests)### Unit testing ###Unit tests are the smallest tests available. The first test implemented in NetCICD is a unit test: testing if CEF is running. The good thing about unit tests is that as soon as the testing script is ready, it can be re-used time and time again. Where 100% code coverage is Utopia for software, it will be achievable for networking.### Integration testing ###In integration testing you test if the chain of units is working together. In networking, this is where you'd expect IGP convergence testing, security hardening etc. In the end it needs to include all non customer related testing. Integration tests are by and large network specific, but based upon a generic test setup. For example, if rerouting needs to be tested, specific links need to be taken out of service. This part is network specific. The path trace mechanism used to validate rerouting is not.### Acceptance testing ###The acceptance tests are the tests where the customer specific implementation is tested before delivery to the customer. Acceptance testing in NetCICD is thus aimed at the functionality to be deliverd for that specific customer.Resulting from the push, Jenkins can start NetCICD to start a VIRL LAB, test the template and on success tear the lab down again. All logging is then in Jenkins. On failure, the lab remains in the state where it failed.